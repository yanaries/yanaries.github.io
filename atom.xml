<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白羊独立博客</title>
  
  <subtitle>爱技术爱生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yanaries.github.io/"/>
  <updated>2018-07-25T10:05:37.796Z</updated>
  <id>http://yanaries.github.io/</id>
  
  <author>
    <name>Yan Chang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库基础深入</title>
    <link href="http://yanaries.github.io/2018/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%B7%B1%E5%85%A5/"/>
    <id>http://yanaries.github.io/2018/07/24/数据库基础深入/</id>
    <published>2018-07-24T06:26:33.000Z</published>
    <updated>2018-07-25T10:05:37.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h1><h3 id="第一范式-列不可分"><a href="#第一范式-列不可分" class="headerlink" title="第一范式 列不可分"></a>第一范式 列不可分</h3><p><strong>1NF(第一范式)是对属性具有原子性要求，不可再分</strong><br>例如  学号  姓名  性别  出生年月<br>如果认为最后一列还可以再分成出生年，出生月，出生日，则它就不满足第一范式的要求。</p><h3 id="第二范式-消除非主属性对码的部分函数依赖"><a href="#第二范式-消除非主属性对码的部分函数依赖" class="headerlink" title="第二范式 消除非主属性对码的部分函数依赖"></a>第二范式 消除非主属性对码的部分函数依赖</h3><p><strong>2NF（第二范式）是对记录有唯一性的要求，即实体的唯一性，不存在部分依赖，每一列与主键都相关，例如：</strong></p><p> 学号 课程号 姓名 学分</p><p> 该表明显说明了两个事物：学生信息和课程信息；正常的依赖应该是：学分依赖课程号，姓名依赖学号，但这里存在非主键字段对码的部分依赖，即与主键不相关，不满足第二范式的要求。<br> <strong>可能存在的问题</strong></p><ul><li>数据冗余：每条记录都含有相同信息；</li><li>删除异常：删除所有学生成绩，就把课程信息全删除了；</li><li>插入异常：学生未选课，无法记录进数据库；</li><li>更新异常: 调整课程学分，所有行都调整。<br><strong>正确的做法：</strong><br>课程号 学分<br>学号 姓名<br>学号 课程号 成绩<h3 id="第三范式-消除非主属性对码的传递函数依赖"><a href="#第三范式-消除非主属性对码的传递函数依赖" class="headerlink" title="第三范式 消除非主属性对码的传递函数依赖"></a>第三范式 消除非主属性对码的传递函数依赖</h3>3NF(第三范式)对字段有冗余性的要求，任何字段不能由其它字段派生出来，它要求字段没有冗余，即不存在依赖传递，例如：<br>学号 姓名 年龄 学院 学院电话<br>很明显，学院电话是一个冗余字段，因为存在依赖传递：（学号）→（学生）→（学院）→（学院电话）<br>可能会存在的问题：<br>数据冗余：有重复值<br>更新异常：有重复的冗余信息，修改时需要修改多条记录，否则会出现数据不一致的情况<br><strong>正确的做法：</strong><br>学号 姓名 年龄 学院<br>学院  学院电话<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1>什么是索引？<br>索引是对数据表中一个或者多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中的数据<br>你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。<br>底层数据结构是什么，为什么使用这种数据结构？<br>（1）底层数据结构是B+树：<br>在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。<br>（2）使用B+树的原因：<br>查找速度快、效率高，在查找的过程中，每次都能抛弃掉一部分节点，减少遍历个数。（此时，你应该在白纸上画出什么是B+树）<br>索引的分类<br>唯一索引：唯一索引不允许两行具有相同的索引值<br>主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空<br>聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个<br>非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个<br>索引的优缺点？<br>1.优点<br>大大加快数据的检索速度，这也是创建索引的最主要原因<br>加速表与表之间的连接<br>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组与排序的时间<br>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性<br>（2）缺点：<br>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；<br>空间方面：索引需要占物理空间。<br>什么样的字段适合创建索引？<br>经常做查询选择的字段<br>经常做表连接的字段<br>经常出现在order by, group by, distinct 后面的字段<br>创建索引时需要注意什么？<br>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；<br>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；<br>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。<br>4）听说过事务吗？<br>事务简单来说：一个Session中所进行的所有操作，要么同时成功，要么同时失败；作为单个逻辑工作单元执行的一系列操作，满足四大特性：<br>1.原子性（Atomicity）：事务作为一个整体被执行 ，要么全部执行，要么全部不执行<br>2.隔离性（Consistency）：保证数据库状态从一个一致状态转变为另一个一致状态<br>3.一致性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行<br>4.持久性（Durability）：一个事务一旦提交，对数据库的修改应该永久保存<br>实例说明：<br>/*</li><li>我们来模拟A向B账号转账的场景</li><li>A和B账户都有1000块，现在我让A账户向B账号转500块钱<br>*<br>**/<br>//JDBC默认的情况下是关闭事务的，下面我们看看关闭事务去操作转账操作有什么问题</li></ul><p>//A账户减去500块<br>String sql = “UPDATE a SET money=money-500 “;<br>preparedStatement = connection.prepareStatement(sql);<br>preparedStatement.executeUpdate();</p><p>//B账户多了500块<br>String sql2 = “UPDATE b SET money=money+500”;<br>preparedStatement = connection.prepareStatement(sql2);<br>preparedStatement.executeUpdate();<br>从上面看，我们的确可以发现A向B转账，成功了。可是如果A向B转账的过程中出现了问题呢？下面模拟一下<br>// A账户减去500块<br>String sql = “UPDATE a SET money=money-500 “;<br>preparedStatement = connection.prepareStatement(sql);<br>preparedStatement.executeUpdate();</p><p>// 这里模拟出现问题<br>int a = 3 / 0;</p><p>String sql2 = “UPDATE b SET money=money+500”;<br>preparedStatement = connection.prepareStatement(sql2);<br>preparedStatement.executeUpdate();<br>显然，上面代码是会抛出异常的，我们再来查询一下数据。A账户少了500块钱，B账户的钱没有增加。这明显是不合理的。<br>我们可以通过事务来解决上面出现的问题：</p><pre><code>// 开启事务,对数据的操作就不会立即生效。connection.setAutoCommit(false);// A账户减去500块String sql = &quot;UPDATE a SET money=money-500 &quot;;preparedStatement = connection.prepareStatement(sql);preparedStatement.executeUpdate();// 在转账过程中出现问题int a = 3 / 0;// B账户多500块String sql2 = &quot;UPDATE b SET money=money+500&quot;;preparedStatement = connection.prepareStatement(sql2);preparedStatement.executeUpdate();// 如果程序能执行到这里，没有抛出异常，我们就提交数据connection.commit();// 关闭事务【自动提交】connection.setAutoCommit(true);</code></pre><p>} catch(SQLException e) {<br>    try {<br>        // 如果出现了异常，就会进到这里来，我们就把事务回滚【将数据变成原来那样】<br>        connection.rollback();</p><pre><code>    // 关闭事务【自动提交】    connection.setAutoCommit(true);} catch (SQLException e1) {    e1.printStackTrace();}</code></pre><p>}<br>上面的程序也一样抛出了异常，A账户钱没有减少，B账户的钱也没有增加。<br>注意：当Connection遇到一个未处理的SQLException时，系统会非正常退出，事务也会自动回滚，但如果程序捕获到了异常，是需要在catch中显式回滚事务的。<br>5）事务的并发问题有哪几种？<br>1.丢失更新：一个事务的更新覆盖了另一个事务的更新；<br>2.脏读：一个事务读取了另一个事务未提交的数据；<br>3.幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。<br>4.不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；<br>6）事务的隔离级别有哪几种？<br>隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。ANSI标准定义了4个隔离级别，MySQL的InnoDB都支持，分别是：<br>1.读未提交（READ UNCOMMITTED）：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没 commit 的数据，这样可能会提高性能，但是会导致脏读问题；<br>2.读已提交（READ COMMITTED）：在一个事务中只允许对其它事务已经 commit 的记录可见，该隔离级别不能避免不可重复读问题；<br>3.可重复读（REPEATABLE READ）：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务 commit 或 rollback。但是，其他事务的 insert/delete 操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。在一个事务中重复 select 的结果一样，除非本事务中 update 数据库。<br>4.序列化（SERIALIZABLE）：最高级别的隔离，只允许事务串行执行。<br>MySQL默认的隔离级别是可重复读（REPEATABLE READ）<br>MySql 的事务支持<br>MySQL的事务支持不是绑定在MySQL服务器本身，而是与存储引擎相关：</p><p>MyISAM：不支持事务，用于只读程序提高性能；<br>InnoDB：支持ACID事务、行级锁、并发；<br>Berkeley DB：支持事务。<br>7）什么是视图？以及视图的使用场景有哪些？<br>试图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改、查、操作，视图通常是有一个表或者多个表的行或者列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。<br>如下两种场景一般会使用到视图：<br>1.不希望访问者获取整个表的信息，只暴露部分字段给访问者，所以就建一个虚表，就是视图。<br>2.查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。<br>注意：这个视图是在数据库中创建的 而不是用代码创建的。<br>8）drop,delete与truncate的区别？<br>drop 直接删除表；truncate 删除表中数据，再插入时自增长id又从1开始 ；delete 删除表中数据，可以加where字句。</p><p>drop table：<br>属于DDL（Data Definition Language，数据库定义语言）<br>不可回滚<br>不可带 where<br>表内容和结构删除<br>删除速度快<br>truncate table：<br>属于DDL（Data Definition Language，数据库定义语言）<br>不可回滚<br>不可带 where<br>表内容删除<br>删除速度快<br>delete from：<br>属于DML<br>可回滚<br>可带where<br>表结构在，表内容要看where执行的情况<br>删除速度慢,需要逐行删除<br>使用简要说明：<br>不再需要一张表的时候，用drop<br>想删除部分数据行时候，用delete，并且带上where子句<br>保留表而删除所有数据的时候用truncate<br>9）触发器的作用？<br>触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。<br>10）数据库的乐观锁和悲观锁是什么？<br>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<br>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>悲观锁是一种利用数据库内部机制提供的锁的方式，也就是对更新的数据加锁，这样在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对数据进行更新了，这就是悲观锁的实现方式。<br>MySQL InnoDB中使用悲观锁：<br>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。 set autocommit=0;<br>//0.开始事务<br>begin;/begin work;/start transaction; (三者选一就可以)<br>//1.查询出商品信息<br>select status from t_goods where id=1 for update;<br>//2.根据商品信息生成订单<br>insert into t_orders (id,goods_id) values (null,1);<br>//3.修改商品status为2<br>update t_goods set status=2;<br>//4.提交事务<br>commit;/commit work;<br>上面的查询语句中，我们使用了 select…for update 的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。<br>上面我们提到，使用 select…for update 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。<br>优点与不足：</p><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<br>乐观锁是一种不会阻塞其他线程并发的控制，它不会使用数据库的锁进行实现，它的设计里面由于不阻塞其他线程，所以并不会引起线程频繁挂起和恢复，这样便能够提高并发能力，所以也有人把它称为非阻塞锁。一般的实现乐观锁的方式就是记录数据版本。<br>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。<br>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。<br>使用版本号实现乐观锁：<br>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p><p>1.查询出商品信息<br>select (status,status,version) from t_goods where id=#{id}<br>2.根据商品信息生成订单<br>3.修改商品status为2<br>update t_goods<br>set status=2,version=version+1<br>where id=#{id} and version=#{version};<br>优点与不足：</p><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。<br>11）超键、候选键、主键、外键分别是什么？<br>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。<br>候选键（候选码）：是最小超键，即没有冗余元素的超键。<br>主键（主码）：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。<br>外键：在一个表中存在的另一个表的主键称此表的外键。<br>候选码和主码：<br>例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）<br>12）SQL 约束有哪几种？<br>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。<br>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。<br>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。<br>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。<br>CHECK: 用于控制字段的值范围。<br>13）MySQL存储引擎中的MyISAM和InnoDB区别详解<br>在MySQL 5.5之前，MyISAM是mysql的默认数据库引擎，其由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然MyISAM性能极佳，但却有一个显著的缺点： 不支持事务处理。不过，MySQL也导入了另一种数据库引擎InnoDB，以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。<br>InnoDB是MySQL的数据库引擎之一，其由Innobase oy公司所开发，2006年五月由甲骨文公司并购。与传统的ISAM、MyISAM相比，InnoDB的最大特色就是支持ACID兼容的事务功能，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。具体地，MyISAM与InnoDB作为MySQL的两大存储引擎的差异主要包括：<br>存储结构：每个MyISAM在磁盘上存储成三个文件：第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义，数据文件的扩展名为.MYD (MYData)，索引文件的扩展名是.MYI (MYIndex)。InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。<br>存储空间：MyISAM可被压缩，占据的存储空间较小，支持静态表、动态表、压缩表三种不同的存储格式。InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。<br>可移植性、备份及恢复：MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便，同时在备份和恢复时也可单独针对某个表进行操作。InnoDB免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。<br>事务支持：MyISAM强调的是性能，每次查询具有原子性，其执行数度比InnoDB类型更快，但是不提供事务支持。InnoDB提供事务、外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力。<br>AUTO_INCREMENT：在MyISAM中，可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，它可以根据前面几列进行排序后递增。InnoDB中必须包含只有该字段的索引，并且引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。<br>表锁差异：MyISAM只支持表级锁，用户在操作MyISAM表时，select、update、delete和insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。InnoDB支持事务和行级锁。行锁大幅度提高了多用户并发操作的新能，但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。<br>全文索引：MyISAM支持 FULLTEXT类型的全文索引；InnoDB不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。<br>表主键：MyISAM允许没有任何索引和主键的表存在，索引都是保存行的地址。对于InnoDB，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。<br>表的具体行数：MyISAM保存表的总行数，select count() from table;会直接取出出该值；而InnoDB没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。<br>CURD操作：在MyISAM中，如果执行大量的SELECT，MyISAM是更好的选择。对于InnoDB，如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。<br>外键：MyISAM不支持外键，而InnoDB支持外键。<br>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁、外键等等。尤其在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，必须需要注意的是，任何一种表都不是万能的，合适的才是最好的，才能最大的发挥MySQL的性能优势。如果是不复杂的、非关键的Web应用，还是可以继续考虑MyISAM的，这个具体情况具体考虑。<br>14）MyIASM和Innodb两种引擎所使用的索引的数据结构是什么？<br>答案:都是B+树!</p><p>MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。<br>Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。<br>15）varchar和char的区别<br>char是一种固定长度的类型，varchar是一种可变长度的类型，例如：<br>定义一个char[10]和varchar[10]，如果存进去的是 ‘test’，那么char所占的长度依然为10，除了字符 ‘test’ 外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的<br>char的存取速度还是要比varchar要快得多，因为其长度固定，方便程序的存储于查找<br>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar是以空间效率为首位。<br>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。<br>两者的存储数据都非unicode的字符数据。<br>16）主键、自增主键、主键索引与唯一索引概念区别<br>1.主键：指字段 唯一、不为空值 的列；<br>2.主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；<br>3.自增主键：字段类型为数字、自增、并且是主键；<br>4.唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。<br>17）主键就是聚集索引吗？主键和索引有什么区别？<br>主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。<br>18）实践中如何优化MySQL<br>实践中，MySQL的优化主要涉及SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面，如下图所示：<br>——————&gt;成本 高 —————&gt;<br>SQL及索引  – 数据库表结构 — 系统配置 —硬件<br>&lt;—————-效果高&lt;——————-<br>⑴ SQL语句优化：<br>SQL语句的优化主要包括三个问题，即如何发现有问题的SQL、如何分析SQL的执行计划以及如何优化SQL，下面将逐一解释。<br>① 怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）</p><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。慢查询日志的相关参数如下所示：<br>通过MySQL的慢查询日志，我们可以查询出执行的次数多占用的时间长的SQL、可以通过pt_query_disgest(一种mysql慢日志分析工具)分析Rows examine(MySQL执行器需要检查的行数)项去找出IO大的SQL以及发现未命中索引的SQL，对于这些SQL，都是我们优化的对象。<br>② 通过explain查询和分析SQL的执行计划：<br>使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。<br>③ SQL语句的优化：</p><p>1.优化insert语句：一次插入多值；</p><p>2.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描；</p><p>3.应尽量避免在 where 子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描；</p><p>4.优化嵌套查询：子查询可以被更有效率的连接(Join)替代；</p><p>5.很多时候用 exists 代替 in 是一个好的选择。</p><p>6.选择最有效率的表名顺序：数据库的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表将被最先处理<br>在FROM子句中包含多个表的情况下：</p><p>如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推<br>也就是说：选择记录条数最少的表放在最后<br>如果有3个以上的表连接查询：</p><p>如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。<br>也就是说：被其他表所引用的表放在最后<br>7.用IN代替OR：</p><p>select <em> from emp where sal = 1500 or sal = 3000 or sal = 800;<br>select </em> from emp where sal in (1500,3000,800);<br>8.SELECT子句中避免使用<em>号：<br>我们最开始接触 SQL 的时候，“</em>” 号是可以获取表中全部的字段数据的，但是它要通过查询数据字典完成，这意味着将消耗更多的时间，而且使用 “*” 号写出来的 SQL 语句也不够直观。<br>⑵ 索引优化：<br>建议在经常作查询选择的字段、经常作表连接的字段以及经常出现在 order by、group by、distinct 后面的字段中建立索引。但必须注意以下几种可能会引起索引失效的情形：</p><p>以 “%(表示任意0个或多个字符)” 开头的 LIKE 语句，模糊匹配；</p><p>OR语句前后没有同时使用索引；</p><p>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</p><p>对于多列索引，必须满足最左匹配原则(eg,多列索引col1、col2和col3，则 索引生效的情形包括col1或col1，col2或col1，col2，col3)。<br>⑶ 数据库表结构的优化：<br>① 选择合适数据类型：</p><p>使用较小的数据类型解决问题；<br>使用简单的数据类型(mysql处理int要比varchar容易)；<br>尽可能的使用not null 定义字段；<br>尽量避免使用text类型，非用不可时最好考虑分表；<br>② 表的范式的优化：</p><p>一般情况下，表的设计应该遵循三大范式。<br>③ 表的垂直拆分：</p><p>把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段：<br>把不常用的字段单独放在同一个表中；<br>把大字段独立放入一个表中；<br>把经常使用的字段放在一起；<br>这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单<br>④ 表的水平拆分：</p><p>表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：<br>对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；<br>针对不同的hashID将数据存入不同的表中；<br>表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处：</p><p>表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；<br>表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。<br>需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)。</p><p>⑷ 系统配置的优化：<br>操作系统配置的优化：增加TCP支持的队列数</p><p>mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances）<br>⑸ 硬件的优化：<br>CPU：核心数多并且主频高的<br>内存：增大内存<br>磁盘配置和选择：磁盘性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三大范式&quot;&gt;&lt;a href=&quot;#三大范式&quot; class=&quot;headerlink&quot; title=&quot;三大范式&quot;&gt;&lt;/a&gt;三大范式&lt;/h1&gt;&lt;h3 id=&quot;第一范式-列不可分&quot;&gt;&lt;a href=&quot;#第一范式-列不可分&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="blog" scheme="http://yanaries.github.io/categories/blog/"/>
    
    
      <category term="文章" scheme="http://yanaries.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>spring 深入理解</title>
    <link href="http://yanaries.github.io/2018/07/20/spring-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://yanaries.github.io/2018/07/20/spring-深入理解/</id>
    <published>2018-07-20T05:39:12.000Z</published>
    <updated>2018-07-20T07:28:28.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识-Spring-框架"><a href="#认识-Spring-框架" class="headerlink" title="认识 Spring 框架"></a>认识 Spring 框架</h1><p>Spring 框架是 Java 应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括 <strong>IoC (Inversion of Control，控制反转)</strong> 和 <strong>AOP(Aspect Oriented Programming，面向切面编程).</strong></p><h2 id="什么是-Spring："><a href="#什么是-Spring：" class="headerlink" title="什么是 Spring："></a>什么是 Spring：</h2><ol><li>Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。</li><li>Spring 提倡以“最少侵入”的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring</li></ol><ul><li><strong>适用范围：任何 Java 应用</strong></li><li><strong>Spring 的根本使命：简化 Java 开发</strong><h2 id="Spring-的优势"><a href="#Spring-的优势" class="headerlink" title="Spring 的优势"></a>Spring 的优势</h2></li><li><strong>低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦）</strong></li><li><strong>声明式事务管理（基于切面和惯例）</strong></li><li><strong>方便集成其他框架（如MyBatis、Hibernate）</strong></li><li><strong>降低 Java 开发难度</strong></li><li><strong>Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式）</strong><h2 id="Spring-能帮我们做什么"><a href="#Spring-能帮我们做什么" class="headerlink" title="Spring 能帮我们做什么"></a>Spring 能帮我们做什么</h2>①. <strong>Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。</strong><br>②. <strong>Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。</strong><br>③. <strong>Spring 能非常简单的帮我们管理数据库事务。</strong><br>④. <strong>Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。</strong><br>⑤. <strong>Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。</strong><br>⑥. <strong>Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。</strong><h1 id="Spring-IoC-概述"><a href="#Spring-IoC-概述" class="headerlink" title="Spring IoC 概述"></a>Spring IoC 概述</h1><strong>IoC：Inverse of Control（控制反转）</strong></li><li>读作“反转控制”，更好理解，不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</li><li>正控：若要使用某个对象，需要自己去负责对象的创建</li><li>反控：若要使用某个对象，只需要从 Spring 容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架</li><li>好莱坞法则：Don’t call me ,I’ll call you<br><strong>控制反转是一种通过描述（在 Java 中可以是 XML 或者注解）并通过第三方（Spring）去产生或获取特定对象的方式。</strong></li><li>好处：<br>降低对象之间的耦合<br>我们不需要理解一个类的具体实现，只需要知道它有什么用就好了（直接向 IoC 容器拿）<h2 id="Spring-IoC-容器的设计"><a href="#Spring-IoC-容器的设计" class="headerlink" title="Spring IoC 容器的设计"></a>Spring IoC 容器的设计</h2>Spring IoC 容器的设计主要是基于以下两个接口：<h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3></li><li>ApplicationContext<br>其中 ApplicationContext 是 BeanFactory 的子接口之一，<strong>换句话说：BeanFactory 是 Spring IoC 容器所定义的最底层接口，</strong> <strong>而 ApplicationContext 是其最高级接口之一，</strong>并对 BeanFactory 功能做了许多的扩展，所以在绝大部分的工作场景下，都会使用 ApplicationContext 作为 Spring IoC 容器。</li><li>BeanFactory<br>BeanFactory 位于设计的最底层，它提供了 Spring IoC 最底层的设计.<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3>根据 ApplicationContext 的类继承关系图，可以看到 ApplicationContext 接口扩展了许许多多的接口，因此它的功能十分强大，所以在实际应用中常常会使用到的是 ApplicationContext 接口，因为 BeanFactory 的方法和功能较少，而 ApplicationContext 的方法和功能较多。<br><strong>BeanFactory 和 ApplicationContext 的区别：</strong><br><strong>BeanFactory：</strong>是Spring中最底层的接口，只提供了最简单的IoC功能,负责配置，创建和管理bean。<br>在应用中，一般不使用 BeanFactory，而推荐使用ApplicationContext（应用上下文），原因如下。<br><strong>ApplicationContext：</strong><br>1.继承了 BeanFactory，拥有了基本的 IoC 功能；<br>2.除此之外，ApplicationContext 还提供了以下功能：<br>① 支持国际化；<br>② 支持消息机制；<br>③ 支持统一的资源加载；<br>④ 支持AOP功能；<h2 id="Spring-IoC-的容器的初始化和依赖注入"><a href="#Spring-IoC-的容器的初始化和依赖注入" class="headerlink" title="Spring IoC 的容器的初始化和依赖注入"></a>Spring IoC 的容器的初始化和依赖注入</h2>虽然 Spring IoC 容器的生成十分的复杂，但是大体了解一下 Spring IoC 初始化的过程还是必要的。这对于理解 Spring 的一系列行为是很有帮助的。</li></ul><p><strong>注意：Bean 的定义和初始化在 Spring IoC 容器是两大步骤，它是先定义，然后初始化和依赖注入的。</strong></p><ul><li>Bean 的定义分为 3 步：<br>1.Resource 定位<br>Spring IoC 容器先根据开发者的配置，进行资源的定位，在 Spring 的开发中，通过 XML 或者注解都是十分常见的方式，定位的内容是由开发者提供的。<br>2.BeanDefinition 的载入<br>这个时候只是将 Resource 定位到的信息，保存到 Bean 定义（BeanDefinition）中，此时并不会创建 Bean 的实例<br>3.BeanDefinition 的注册<br>这个过程就是将 BeanDefinition 的信息发布到 Spring IoC 容器中<br>注意：此时仍然没有对应的 Bean 的实例。<br>做完了以上 3 步，Bean 就在 Spring IoC 容器中被定义了，而没有被初始化，更没有完成依赖注入，也就是没有注入其配置的资源给 Bean，那么它还不能完全使用。</li></ul><p>对于初始化和依赖注入，Spring Bean 还有一个配置选项——【lazy-init】，其含义就是是否初始化 Spring Bean。在没有任何配置的情况下，它的默认值为 default，实际值为 false，也就是 Spring IoC 默认会自动初始化 Bean。如果将其设置为 true，那么只有当我们使用 Spring IoC 容器的 getBean 方法获取它时，它才会进行 Bean 的初始化，完成依赖注入。</p><h2 id="IoC-是如何实现的"><a href="#IoC-是如何实现的" class="headerlink" title="IoC 是如何实现的"></a>IoC 是如何实现的</h2><p>最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎：</p><ul><li>读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名</li><li>使用反射的API，基于类名实例化对应的对象实例</li><li><p>将对象实例，通过构造函数或者 setter，传递给 JuiceMaker<br>我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！</p><h1 id="Spring-AOP-简介"><a href="#Spring-AOP-简介" class="headerlink" title="Spring AOP 简介"></a>Spring AOP 简介</h1><p>如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。</p><h2 id="AOP-即-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-即-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP 即 Aspect Oriented Program 面向切面编程"></a>AOP 即 Aspect Oriented Program 面向切面编程</h2><p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p></li><li><p>所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务</p></li><li>所谓的周边功能，比如性能统计，日志，事务管理等等<br>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面</li></ul><p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</p><h2 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h2><p>AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><h2 id="AOP-当中的概念："><a href="#AOP-当中的概念：" class="headerlink" title="AOP 当中的概念："></a>AOP 当中的概念：</h2><ul><li>切入点（Pointcut）<br>在哪些类，哪些方法上切入（where）</li><li>通知（Advice）<br>在方法执行的什么实际（when:方法前/方法后/方法前后）做什么（what:增强的功能）</li><li>切面（Aspect）<br>切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强！</li><li>织入（Weaving）<br>把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）<br><strong>OP 的一个思想：让关注点代码与业务代码分离！</strong></li></ul><h2 id="实际的代码"><a href="#实际的代码" class="headerlink" title="实际的代码"></a>实际的代码</h2><p><strong>我们来实际的用代码感受一下</strong></p><p>1.在 Package【pojo】下新建一个【Landlord】类（我百度翻译的包租婆的英文）：</p><p>package pojo;</p><p>import org.springframework.stereotype.Component;</p><p>@Component(“landlord”)<br>public class Landlord {</p><pre><code>public void service() {    // 仅仅只是实现了核心的业务功能    System.out.println(&quot;签合同&quot;);    System.out.println(&quot;收房租&quot;);}</code></pre><p>}<br>2.在 Package【aspect】下新建一个中介商【Broker】类（我还是用的翻译…）：</p><p>package aspect;</p><p>import org.aspectj.lang.annotation.After;<br>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.springframework.stereotype.Component;</p><p>@Component<br>@Aspect<br>class Broker {</p><pre><code>@Before(&quot;execution(* pojo.Landlord.service())&quot;)public void before(){    System.out.println(&quot;带租客看房&quot;);    System.out.println(&quot;谈价格&quot;);}@After(&quot;execution(* pojo.Landlord.service())&quot;)public void after(){    System.out.println(&quot;交钥匙&quot;);}</code></pre><p>}<br>3.在 applicationContext.xml 中配置自动注入，并告诉 Spring IoC 容器去哪里扫描这两个 Bean：</p><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemalocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"><pre><code>&lt;context:component-scan base-package=&quot;aspect&quot; /&gt;&lt;context:component-scan base-package=&quot;pojo&quot; /&gt;&lt;aop:aspectj-autoproxy/&gt;</code></pre><p></p></beans><br>4.在 Package【test】下编写测试代码：<p></p><p>package test;</p><p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>import pojo.Landlord;</p><p>public class TestSpring {</p><pre><code>public static void main(String[] args) {    ApplicationContext context =            new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);    Landlord landlord = (Landlord) context.getBean(&quot;landlord&quot;, Landlord.class);    landlord.service();}</code></pre><p>}<br>5.<strong>执行看到效果：</strong></p><p>  带租客看房<br>  谈价格<br>  签合同<br>  收房租<br>  交钥匙</p><p>这个例子使用了一些注解，现在看不懂没有关系，但我们可以从上面可以看到，我们在 Landlord 的 service() 方法中仅仅实现了核心的业务代码，其余的关注点功能是根据我们设置的切面自动补全的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识-Spring-框架&quot;&gt;&lt;a href=&quot;#认识-Spring-框架&quot; class=&quot;headerlink&quot; title=&quot;认识 Spring 框架&quot;&gt;&lt;/a&gt;认识 Spring 框架&lt;/h1&gt;&lt;p&gt;Spring 框架是 Java 应用最广的框架，它的成功来源
      
    
    </summary>
    
      <category term="blog" scheme="http://yanaries.github.io/categories/blog/"/>
    
    
      <category term="文章" scheme="http://yanaries.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>学习方法</title>
    <link href="http://yanaries.github.io/2018/07/18/learning/"/>
    <id>http://yanaries.github.io/2018/07/18/learning/</id>
    <published>2018-07-18T03:03:42.000Z</published>
    <updated>2018-07-19T06:05:51.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自我管理"><a href="#自我管理" class="headerlink" title="自我管理"></a>自我管理</h1><p><strong>学霸不会困，靠的不是体力，是自我管理.</strong><br>一天分成三个阶段，规律作息，精进细节，才可以游刃有余。身体大家都差不多，差别在于精力分配与时间规划。</p><h2 id="早晨篇"><a href="#早晨篇" class="headerlink" title="早晨篇"></a>早晨篇</h2><ul><li>早晨解决三件事:1.起床 2.清醒 3.专注先说起床。头天晚上晚睡，第二天难免晚起。所以别熬夜。一天都没有熬夜。真努力就别熬夜，熬夜是懒惰的证明。（博士生和企业员工被迫熬夜不在此列…默默同情比心）一天两天失眠导致晚睡，目测不会影响次日状态，不要长期熬夜就好。再说清醒。</li><li>早晨一定要见到阳光。早晨没有接触阳光，人难以完全清醒。我每天早晨起床先穿好衣服出门晒一会儿太阳，不到十分钟，就会神清气爽。这是由于阳光刺激大脑合成血清素，血清素调节我们的清醒度。</li><li>早晨要适度运动。所谓适度，就是把身体活动开，微微气喘就可以了，千万不要运动过度，否则过度劳累反而影响状态。<br>最后说专注。早晨千万不可以接触杂乱信息，包括知乎在内，微博段子抖音快手今日头条….通通不要看。因为接受杂乱无章的碎片信息会让你头脑混乱，毁掉一整天的状态。我上午一般不碰手机，也很少有人上午联系到我。</li><li>早晨应该立即投入到紧张、有序、逻辑化、体系化的工作中，并将专注的状态尽可能延续。很多名作家都有上午写作的习惯，毛姆上午写作，下午逛街看书，晚上会客；海明威上午站着写作，下午和晚上就读书、做采访；村上春树从早晨一直写到下午，独自闷在屋里，有时状态连贯甚至不吃午饭，自称“罐头工作法”；巴尔扎克最特殊，晚8点至12点睡觉，半夜12点起床一直写到中午12点，这样就把一天的开始与巴黎最安静的时段结合在一起了。我在巡讲中接触到许多优秀的企业家，他们往往也是最擅长利用上午的时间来处理重要的事务，而且乔布斯传记里也提到：乔布斯4点起床，一直专注于工作，绝不受任何打扰。因此古今中外的精英们都懂得利用好早晨才是利用好一天的关键。</li><li>早晨一定要吃早饭，这个不用多说了。<h2 id="中午篇"><a href="#中午篇" class="headerlink" title="中午篇"></a>中午篇</h2>想要保持午后状态良好，还是三件事:1.饮食 2.午休 3.运动先说饮食。</li><li>不要吃快速升高血糖的食物，不要吃太快吃太饱。碳水化合物、多油盐食物，都会让你血糖飞速上升，昏昏欲睡。午餐吃些鸡肉、蔬菜之类的最好不过。</li><li>再说午休。适量午休很重要，我一般睡20到40分钟，小憩之后，精神饱满。出外巡讲的时候，就在车里眯一会儿，在学校上课的时候，就在桌子上趴一会儿。</li><li>我最后说说运动。个人感觉下午是体力最充沛的时候，此时跑步健身半小时，能够增加氧气吸入量，提高多巴胺、去甲肾上腺素、血清素等脑内物质的浓度，对清醒头脑提升效率很有帮助。没有场地健身的话，爬楼梯也行。大声唱歌也有类似的效果。我在宿舍装了门上单杠，下午做些引体向上，很能调整状态。<h2 id="晚上篇"><a href="#晚上篇" class="headerlink" title="晚上篇"></a>晚上篇</h2>三件事:1.冥想 2.间歇 3.总结首先是冥想。</li><li>吃过晚饭，进入黄昏。经过一天的劳累谁都难免松懈。此时很重要的是“冥想”。国学大师钱穆先生每次舟车劳顿回到家中，都是冥想十五分钟，然后伏案工作。这里的冥想并不一定要像禅宗那样莲花坐，其实更像是“闭目养神”，眼观鼻鼻观心，去除杂念，收摄心神，从而提升效率与专注度。</li><li>再说间歇。晚上脑力体力都难以饱满，所以做事情要讲求间歇，“番茄工作法”是不错的选择，每25分钟休息5分钟，现在也有app作辅助了。不过还是要注意，不能死板地遵守番茄工作法。有些事情不是25分钟就能完成的，偏偏又很重要不能打断，所以必须适度延长时间。比如我写文章，一次就是两三小时，不敢中断，否则逻辑框架就会不完整。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>最后是总结。总结可以写成日记，可以画成表格，总结你一天所做的事，写几句评价。不要太复杂，尽可能简洁。总结最好睡前做。睡前半小时内不要剧烈运动，不要做高强度脑力劳动（比如做数学题）。这样，就会有高效而充实的一天。把这样的一天又一天坚持下去，就必将走向优秀。我都是依靠时间管理的法则。管理好自己，你才能更强大。<br>与君共勉！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自我管理&quot;&gt;&lt;a href=&quot;#自我管理&quot; class=&quot;headerlink&quot; title=&quot;自我管理&quot;&gt;&lt;/a&gt;自我管理&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;学霸不会困，靠的不是体力，是自我管理.&lt;/strong&gt;&lt;br&gt;一天分成三个阶段，规律作息，精进细节，才可以
      
    
    </summary>
    
      <category term="blog" scheme="http://yanaries.github.io/categories/blog/"/>
    
    
      <category term="文章" scheme="http://yanaries.github.io/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>博客</title>
    <link href="http://yanaries.github.io/2018/07/17/my-new-post/"/>
    <id>http://yanaries.github.io/2018/07/17/my-new-post/</id>
    <published>2018-07-17T01:02:55.000Z</published>
    <updated>2018-07-17T01:08:09.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Aries-first"><a href="#Aries-first" class="headerlink" title="Aries first"></a>Aries first</h1><p><strong>新的起点，新的开始，加油</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Aries-first&quot;&gt;&lt;a href=&quot;#Aries-first&quot; class=&quot;headerlink&quot; title=&quot;Aries first&quot;&gt;&lt;/a&gt;Aries first&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;新的起点，新的开始，加油&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yanaries.github.io/2018/07/16/hello-world/"/>
    <id>http://yanaries.github.io/2018/07/16/hello-world/</id>
    <published>2018-07-16T08:56:22.275Z</published>
    <updated>2018-07-16T08:56:22.275Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
